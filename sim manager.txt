    while (dispatchRunning) {
        std::unique_lock<std::mutex> lock(dispatchCvMutex); //create the lock object and acquire it
        // Wait for a notification or stop condition
        dispatchCv.wait(//wait to be notified by addMessageToTransmit 
            lock, [this] {//lock object temporary release the mutex, and the lambda function is called to check if the condition is met

            // Check if there is at least one node with a message to transmit
            for (const auto& node : nodes) {
                if (node->getNextTransmittingMessage().has_value()) {
                    return true;//there is at least one, we exit the loop and process the messages
                }
            }
            return !dispatchRunning; //If no node has a message, it checks the value of dispatchRunning. If dispatchRunning is false (we stop the transmission before stopping the simulation for instance) the wait condition is satisfied 
        });

        // Process messages if we received a notification
        for (const auto& node : nodes) {
            std::optional<std::string> message = node->getNextTransmittingMessage();
            if (message) {
                // Get reachable nodes for this node
                const auto& reachableNodes = reachableNodesPerNode[node->getId()];

                // Deliver the message to all reachable nodes
                for (const auto& reachableNode : reachableNodes) {
                    reachableNode->receiveMessage(*message);

                 //   std::cout << "Message transmitted from Node " << node->getId()
                 //             << " to Node " << reachableNode->getId() << ": " << *message << std::endl;
                }
            }
        }
    }